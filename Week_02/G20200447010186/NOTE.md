# Week02学习笔记

## 概念篇

 ### 栈 Stack
 先进后出，类似堆盘子，Last In First Out
 
 时间复杂度：添加、删除为O(1)。 查询为O(n)，因为栈中元素无序

 js中用数组实现栈，栈顶元素为数组末尾元素

 ### 队列 Queue
先进先出，类似排队，First In First Out
 
时间复杂度：添加、删除为O(1)。 查询为O(n)，因为队列中元素无序

js中用数组实现队列，队列头尾分别对应 为 数组首尾元素

### 双端队列 Double End Quene（Deque）

 可以在队列的头添加删除元素，尾添加删除元素
 
 时间复杂度：添加、删除为O(1)。 查询为O(n)，因为双端队列中元素无序

### 散列表

 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展
 
 散列函数是用来将给定值经过计算得到散列值的函数，对于散列表性能来说，散列函数设计的好能大大提高散列表性能
 
散列冲突解决方式：开放寻址法、链表法

装载因子（load factor）来表示散列表中空位的多少

``` 
散列表的装载因子 = 填入表中的元素个数/散列表的长度
```

#### 开放寻址法

线性探测法：
如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那么如何探测位置呢，便用到了线性探测法。原理是当某个值经过散列函数散列后，其在散列表对应的储存位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

二次探测法：基于线性探测法，每次探测的步长单位为n2次方。n为1、2、3... 

双重散列法：不仅使用一个散列函数，而是使用一组散列函数。当第n个散列函数计算出的储存位置被占用时，就采用第n+1个散列函数计算。

链表法：在散列表中，每个储存位置会对应一条链表，如此可存放多个散列值相同的元素

## 做题篇

##### 有效的字母异位词

做法1: 直接将字符串排序之后，再比较两个字符串是否相等。（但是此种方法时间复杂度较高，因为涉及数组的重新排列）

做法2: 利用哈希表储存第一个字符串中每个字母出现的次数。往map里储存的键为该字母，值为该字母出现次数。再根据这个map，去遍历第二个字符串，寻找是否能匹配map中键值，如果有则将此键值对应的出现次数-1，直至减为1时，下一次减操作变为从map中删除此键。最后判断map的size是否等于0

##### 接雨水

做法1: 遍历给定整数，计算每一列可接的雨水单位，最后求和。`` `O(n2)` ``

* 每一列可接的水，其实由它的左最高值和右最高值确定。所以需要对每个元素的左边寻找max_left，右边寻找max_right
* 从整数的遍历，直接从`` `i=1` ` `起，至` ` `i<heights.length-2` ``. 因为首尾列上不可能能接水。
* 找到max_left和max_right后，求其中较小值Math.min(max_left, max_right)
* 比较较小值和当前列的关系，得出仅当较小列height>当前列height时，当前列能装上水，此时才能加到结果中去。
* 每一列能装的水量其实由较小的高度决定，itemWater = min - heights[i]。

其余解法还在理解中，后续理解了会来更新。

## 心得

这一周开始明显吃力了，对于接雨水题和求柱形图中最大面积，要理解很多次解法，在草稿纸上画出过程才能明白原理。
别放弃。走的慢一点，但是不要后退。

