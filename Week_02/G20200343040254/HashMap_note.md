在java中HashMap<E>为非线程安全的散列表实现，内部结构是一个数组(Node<K,V>[] table)的数组 + 链表结合的复合数据结构，以下列出问个人认为比较重要的几个知识点

1.散列函数的设计
常规的散列函数要求是将任意长度的字节，经过散列计算后，变成成为一个固定长度的的字节数据
要求：
key1==key2 则 hash(key1)==hash(key2)
key1!=key2 则 hash(key1)!=hash(key2)

但是在容器散列表的实际需求中，则有些特殊要求
1.计算不能复杂要求足够的快
2.计算出的hash值要尽可能的随机且均匀分布,参考源码如下：
	不直接使用原始key.hashCode()，做二次hash计算，
	static final int hash(Object key) {
	   int h;
	   return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
	}
 	原因：在java中有些数据计算出的哈希值差异主要表现在高位比特处，而在HashMap中的哈希寻址是忽略容量以上的高位的，
 	所以，将高位比特移动到地位后进行异或运算，这样的处理可能尽可能的避免哈希碰撞。同时此操作是位操作方式性能极好.

 3.容量
 	容量要求是2的幂次方，在非拷贝的构造函数采用lazy-load原则，在实际put数据的时候创建table
 4.装载因子load factor 
   装在因子=元素数量/容量，当装载因子越大，说明空闲位置越少，冲突越多，散列表的随机访问性能会下降(O(1)数组-->O(n)链表-->O(logn)红黑树)
   
   实际使用中需要预估容量满足：预估容量= 预估元素数量 * 状态因子
   
   实际使用中若没有特别需求，不要轻易修改JDK默认的装载因子(0.75)，其非常符合通用的场景需求
   
   若需要调整，不要超过0.75,否则会显著增加冲突，降低性能
   
   若因子过小，需要调整预估容量值，否则容易遭成频繁的扩容需求，增加无谓的性能开销，范文性能下将
   
 5.链表-->树化
 
   为什么需要树化？当元素很多，若哈希冲突，则元素都放在了一个 table index指定的桶中，桶结构为链表，由于linked的访问复杂度为线性O(n)性能下降严重，所以链表长度大于一定长度后转成红黑树，将复杂度降为 O(logn)。 	
 
 
 