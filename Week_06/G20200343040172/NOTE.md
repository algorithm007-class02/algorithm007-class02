学习笔记
### 动态规划分析步骤
1. **寻找子问题**
动态规划（Dynamic Programming）的核心要义就是将一个`大问题`拆分为一系列的子问题，通过寻找最优子结构来达到花费最小的代价解决`大问题`的目的。什么叫做最优子结构呢？我个人认识应该就是子问题的最优解。
2. **状态定义**
对于我自己而言，很多问题都不知道怎么用dp来解决问题。虽然dp的模板能背出来来，但就是不会用。很关键的一点可能就是因为不会定义状态。在解决问题的时候，到底该使用一维的dp呢还是用二维的dp呢？dp数组表示什么含义呢？只有把这些想清楚，想明白了，才能进一步往下走。在我做过的题目中dp[i]往往都表示这些含义：`dp[i]表示到第i个元素为止产生的最大或者最小数值之和，最长或者最短的路径和，最多或者最少的可能性`。
3. **dp方程**
这一步当然是最关键的一步，能否得出正确的答案关键就是靠dp方程的定义是否准确。也就是所谓的状态转移方程。dp数组的每一个值都表示一个状态，dp[i]怎么转变为dp[i+1]，或者是dp[i-1]怎么转变为dp[i]呢，这个方程该怎么写呢？目前我大致见过这几种：
* `dp[i] = dp[i-1] +value`：dp[i]等于上一个状态的值加上某一个固定的值
* `dp[i] = dp[i-1] + dp[i-2]`：dp[i]等于前面某几个状态的的值
* `dp[i] = min(dp[i], dp[i - 1)`或者dp[i] = max(dp[i], dp[i - 1)：dp[i]当前的状态值和前面状态值相比，取最大或者最小
* `dp[i][j] =max/min(dp[i][j - 1], dp[i - 1][j])`对于二维的dp，其dp方程有可能是当前元素的顶上一个元素即（i-1，j）的dp值，以及左边一个元素(i，j-1)的dp值进行比较取最大或者最小。也可能是右边一个元素即（i+1，j）的dp值，以及下边一个元素(i+1，j)的dp值进行比较取最大或者最小。也有可能是由对角线上的dp值转移过来的。二维的比较复杂。

### 具体问题具体分析
[LeetCode-322零钱兑换](https://leetcode-cn.com/problems/coin-change/)

#### 读题
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
示例 1:
> 输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```java
// 默认代码模板
class Solution {
    public int coinChange(int[] coins, int amount) {

    }
}
```
#### 思考
如何用dp？
1. **分解子问题**：题目要求的是`凑成总金额所需的最少的硬币个数`。比如示例一中求组成11（元/美金）所需的最少硬币数量。给定的有三种硬币，分别是1，2，5。可以这么分解：分别去求组成11 - 1 = 10所需的最少硬币数量，求组成11 - 2 = 9所需的最少硬币数量，求组成11 - 5 = 6所需的最少硬币数量。这样以来就分为了三个子问题。三个子问题也可以继续按这样分下去。
#### 
2. **状态定义**：dp[i]要表示什么意思？题目要求的是`凑成总金额所需的最少的硬币个数`。分成子问题以后就不是求组成总金额的的硬币个数了。比如求组成11所需的最少硬币数量，分为了三个子问题：【1】，求组成11 - 1 = 10所需的最少硬币数量，【2】、求组成11 - 2 = 9所需的最少硬币数量，【3】求组成11 - 5 = 6所需的最少硬币数量。然后再从中选出一个最小值，则是组成11所需的最少硬币数量。所以dp[i]中的i就可以具体的表示分解以后的金额，比如这里的10，9，6。`dp[10]就表示组成10所需的最少硬币个数`。
#### 
3. **状态方程**。这个题目的状态转移过程比较明显。比如11分解为10，9，6以后。我们只需要求dp[10]，dp[9]，dp[6]的最小值即可。也就是dp[11] = min (dp[10]，dp[9]，dp[6])。但是这样的思维是自顶向下的，使用递归的话如果不使用数组存储来进行记忆的话，效率非常低，重复计算也特别多。
#### 官方的自底向上的解法
官方采用的是自底向上的解法，很老练。对于我这样的新手，思维过程还没转换过来，只有勤加练习才能写成这样的**快准狠**的解题代码。
```java
public class Solution {
  public int coinChange(int[] coins, int amount) {
    int max = amount + 1;
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, max);
    dp[0] = 0;
    for (int i = 1; i <= amount; i++) {
      for (int j = 0; j < coins.length; j++) {
        if (coins[j] <= i) {
          dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
        }
      }
    }
    return dp[amount] > amount ? -1 : dp[amount];
  }
}
```