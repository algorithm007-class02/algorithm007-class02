# Week03学习笔记

## 预习篇

### 树 Tree

根节点：没有父节点的节点

叶子节点 / 叶节点：没有子节点的节点

兄弟节点：拥有同一个父节点的节点互为兄弟节点

节点高度：此节点到叶子节点的最长路径（边数）

节点深度：根节点到此节点的路径

节点层数：节点深度+1

**树的高度**：根节点的高度

### 二叉树

每个节点**最多**有2个子节点：左子节点、右子节点。

##### 满二叉树

所有的叶子节点都在最底层，除了叶子节点本身，所有的节点都有2个子节点

##### 完全二叉树

* 最后一层的叶子节点靠左排列
* 除了叶子节点，其他节点都有2子节点

### 如何存储一棵二叉树

二叉链式储存法：基于指针和引用

顺序储存法：基于数组

### 二叉树的遍历

其中前、中、后的关系，指的是：**该节点**和该节点的**左右子节点**的打印顺序

 设该节点:`` `current` ` ` 该节点的左子节点：` ` `leftChild` ` `  该节点的右子节点：` ` `rightChild` `` 

##### 前序遍历

对于树中任意节点，打印顺序为：`` `current--->leftChild--->rightChild` ``

##### 中序遍历

对于树中任意节点，打印顺序为：`` `leftChild--->current--->rightChild` ``

##### 后序遍历

对于树中任意节点，打印顺序为：`` `leftChild--->rightChild--->current` ``

##### 二叉树遍历时间复杂度

因为每个节点最多会被访问两次，所以为`` `O(2n)` ` `，即` ` `O(n)` ` ` (` ` `n:节点个数` ``)

### 二叉查找树（二叉搜索树）

要求：在没有重复数据情况下，二叉查找树中，每个节点的`` `leftChild < current` ` `，` ` `rightChild > current` ``

##### 查询

``` 
要查询的值为data.data和root比较: 

data < root: 从左子节点开始递归查找
data > root: 从右子节点开始递归查找
data = root: return root
```

##### 插入

``` 
新插入的数据一般都是在叶子节点上。从root开始对每个node比较： 

data < node : node的leftChild为空，直接将该值插入到leftChild位置；如果leftChild不为空，则继续查找
data > node : node的rightChild为空，直接插入到rightChild位置；如果rightChild不为空，则继续查找
```

##### 删除

``` 
针对要删除node的子节点个数的不同，我们需要分三种情况来处理.

1. 如果node无子节点，则直接将node的parent指向该node的指针置为null
2. 如果node有1个子节点，则直接将node的parent指向该node的指针，指向node的child
3. 如果node有2个子节点，则比较复杂。

   方法1:

           需要找到node的右子树中的最小节点（即刚刚大于node的最小值），将node替换为此最小节点，再从原最小节点的位置删除原最小节点。

   方法2:

           需要找到node的左子树中的最大节点（即刚刚小于node的最大值），将node替换为此最大节点，再从原最小节点的位置删除原最大节点。

   方法3：

           将该node标记为已删除，但并不真正去掉。

    方法1/2原理都是寻找到最接近被删除节点的值，将其放在被删除节点的位置    

```

##### 二叉查找树的中序遍历可以输出有序的数据序列，且复杂度为O(n)

因此，二叉查找树也叫作二叉排序树

---

### 堆 Heap

首先 堆是一种特殊的树🌲，那什么条件的树才能称为堆呢。

满足这2点即可：

* 堆是完全二叉树
* 堆中每一个节点的值都必须`` `>=` ` `或` ` `<=` ``其子树中**每个节点**的值

#### 大顶堆 

堆中每个节点的值都`` `>=` ``左右子树中的每个节点的值

#### 小顶堆 

堆中每个节点的值都`` `<=` ``左右子树中的每个节点的值

#### 如何实现一个堆

存储方式：数组

支持的堆核心操作：插入 、 删除堆顶元素

#### 往堆中插入元素

堆化 heapify （这里以大顶堆为例）

定义：对堆重新进行调整，使得继续满足原堆的特性

操作：顺着节点所在的路径，向上或者向下，对比，然后交换

* 自下而上的堆化

    - 让新插入的节点与父节点对比大小，如果发现新node比parent大，则交换位置。依次执行到不大于parent，堆化停止

* 自上而下的堆化同理

#### 删除堆顶元素

堆顶元素存储的就是堆中数据的最大值或者最小值

##### 删除堆顶元素后，将堆中最后一个节点（数组中最后一项）放到堆顶，再采用自上而下的堆化

因移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性

#### 时间复杂度

一个包含n个节点的完全二叉树，树高度不会超过`` `log2n` ``。

堆化的时间复杂度跟树的高度成正比，即`` `O(logn)` ``

插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是`` `O(logn)` ``

#### 如何基于堆进行排序？

堆排序的复杂度为`` `O(nlogn)` ``，且为原地排序算法。如此优秀，是怎么做到的？

> 原地：不借助另一个数组，就在原数组上操作

堆排序大致分为2步。建堆 + 排序

### 图 Graph

> 如何存储微博、微信等这些社交网络的好友关系? 这就是用到了图

##### 基础概念：

树与图都为非线性表结构。树中的元素称为节点，图中的元素称为【顶点】。

图中任意一个顶点可以与任意其他顶点建立关系，这种关系称为【边】。

每个顶点相连接的边的条数，就叫做顶点的【度】

##### 图的分类：

1. 有向图、无向图

	有方向概念的图叫做【有向图】，没有方向概念的图叫做【无向图】

	【有向图】中的度分为：

  + 出度：有多少条边由这个顶点发出的
  + 入度：有多少条边指向了这个顶点

	

2. 带权图

	带权图中每条边都有一个权重，类似QQ中的好友亲密度
    

### 图的存储

##### 1. 领接矩阵法

领接矩阵的底层依赖一个二维数组。

无向图中：

``` 
顶点i和顶点j之间有边，将A[i][j]、A[j][i]标记为1
```

有向图中：

``` 
顶点i和顶点j之间有一条从i指向j的边，将A[i][j]标记为1

顶点i和顶点j之间有一条从i指向j的边，将A[i][j]标记为1
```

带权图中：

``` 
上述的边关系1在带权图中以权重数值标记
```

##### 邻接矩阵法的优缺点

缺点：

对于无向图，`` `如果顶点i、j之间有关系，那么A[i][j]、A[j][i]都会被标记1` ``。实际上我们只需要储存一个就够了。

无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了

优点：

* 邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效
* 方便计算，可以将很多图的计算转变为矩阵之间的计算

##### 2. 领接表法

每个顶点对应一条链表，用来储存与哪些顶点有联系（与这个顶点相连接的其他顶点）。

##### 时间、空间复杂度的关系

领接表法虽然节约了空间，但是比较耗时间。

	比如想找到是否存在从2到4的边，则需要遍历顶点2对应整条链表，看是否有4存在，查询时就没那么高效。
    改进办法：将链表换成其他更高效的数据结构。比如平衡二叉查找树、跳表、散列表。

邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。

---

### 分治

##### 分治算法：分而治之

将原问题划分成n个规模较小，且与原问题相似的子问题，递归地解决这些子问题，最后合并结果，就得到原问题的解。

##### 分治看起来类似递归，那么分治和递归的区别？

分治是一种处理问题的思想，而递归是一种编程技巧。

##### 分治算法一般都适合用递归来实现

分治算法的递归中，每一层递归都会涉及这样的三个操作

1. 分解：将原问题分解成一系列子问题
2. 解决：递归地去求解每个子问题，如果子问题足够小，则直接求解
3. 合并：将子问题结果合并成一个

##### 能用分治算法解决的问题，其需要满足条件

* 原问题与分解成的小问题具有相同的模式
* 原问题分解成的子问题可独立求解，子问题之间无相关性（分治算法和动态规划的明显差异）
* 具有分解终止条件。当问题足够小时，可直接求解
* 可以将子问题合并成原问题，且合并操作复杂度不能太高，否则失去了采用分治的意义

### 回溯

处理思想：

	类似枚举搜素，枚举所有的解法，找到满足期望的解。
    为了有规律枚举所有可能的解，避免遗漏/重复，把问题求解的过程分为多个阶段。
    每个阶段，面对岔路口时随意选择一条路走，当发现走不通时，回退到上一个路口选另外一条路走

---

问题：

**堆化具体实现还要多理解，当前堆化的节点是和哪些节点比较，为什么堆化时间复杂度是O(logn)**

> 在课堂篇中有解答

---

## 课堂篇

### 树🌲

链表可以看作特殊化的树。当有2个`` `next` ``指针时

树可以看作特殊化的图。无环的图即是树

### 二叉搜索树

也称为二叉排序树、有序二叉树、排序二叉树。

是指一颗空树或者具有下列性质的二叉树：

* 左子树上**所有节点**的值均小于它根节点的值
* 右子树上**所有节点**的值均大于它根节点的值
* 左右子树分别也为二叉搜索树。（这就是重复性）

#### 二叉搜索树的中序遍历为升序排列

#### 二叉搜索树的时间复杂度

平均：`` `O(logn)` ``

最坏：退化成链表。`` `O(n)` ``

### 堆 Heap

可以迅速找到一堆数中的最大值或者最小值的抽象数据结构。

大顶堆：根节点为堆中最大值

小顶堆：根节点为堆中最小值

常见堆的实现形式有：二叉堆、斐波那契堆

#### 常见操作 (大顶堆为例）

``` 
find_max: O(1)
delete_max: O(logn)
insert: O(logn) 或 实现很好的情况下为O(1)
```

### 二叉堆

一般通过数组实现二叉堆

* 条件1: 是一棵完全二叉树
* 条件2: 树中任意节点的值总是 >= 其子节点的值

``` 
假设从下标0开始建堆，那么下标为i的节点，和它有联系的节点的对应关系分别为：

左子节点：2*i+1
右子节点：2*i+2
父节点：i-1/2

```

#### 插入操作 insert

1. 新元素一律先插入到堆的尾部
2. 因为此时堆的顺序被破坏，所以要依次向上调整整个堆的结构（一直到根）。
3. 调整规则：新节点和父节点比较，若大于父节点，则和父节点交换位置，直到它不再大于父节点。
4. 复杂度：最坏情况下新节点移动的路径等于堆的高度，即`` `O(logn)` ``

#### 删除堆顶操作 delete

1. 将堆尾元素代替堆顶元素。（堆顶被删除）
2. 依次从堆顶开始向下调整堆的结构
3. 调整规则：新堆顶和左右子节点比较，当左右子节点均大于自己时，选取左右节点中较大的值进行交换位置。
4. 为什么选较大的值，因为交换之后能保证新父节点的值大于原来未被选中的另一个节点
5. 复杂度：最坏情况下，新堆顶找到自己正确的位置要走到最底层，即`` `O(logn)` ``

## 课后思考

#### 树的面试题解法一般都是递归，为什么？

树的结构没有便于循环/遍历的结构，基本上都是左节点右节点形式。而每个节点的结构都类似，故访问子树更好的办法就是对左右子树采用相同的遍历函数。

## 剖析递归

#### 递归组成四大点，顺序性

1. 先列出递归的终止条件（重要），防止无限递归
2. 接下来处理本层逻辑
3. 本层处理完之后，下到下一层去，用参数来标记是哪一层
4. 清扫当前层状态

#### 思维要点

1. 不要人肉进行递归（最大误区）
2. 找问题的可重复性，拆解成最近重复的子问题
3. 使用数学归纳法：最开始最简单的条件是成立的，继续推导当n成立时，n+1也成立

