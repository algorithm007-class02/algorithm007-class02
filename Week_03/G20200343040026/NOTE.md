# 学习笔记

## leetcode_590
1. 使用递归法,首先遍历子节点,在循环中进行递归,最后记录根节点的值,达到二叉树后续遍历的目的,时间复杂度为O(n),空间复杂度O(h),h为树的高度
2. 使用迭代法,,维护两个栈,一个栈记录节点,一个栈记录结果值,先按照前序遍历的顺序进行迭代,最后将结果栈逆序即可得到后序遍历结果,时间复杂度和空间复杂度均为O(n)

## leetcode_589
1. 使用递归法,首先记录根节点的值,再遍历子节点,在遍历子节点的循环中再调用函数形成递归,时间复杂度为O(n),空间复杂度为O(h)
2. 使用迭代法,维护两个栈,一个栈记录节点,一个栈记录结果值,直接按照前序遍历的思路将状态空间写进第一个栈,注意在遍历子节点的时候要取反,时间复杂度和空间复杂度均为O(n)

## leetcode_144
1. 使用递归法,前序遍历则先记录节点值,然后递归节点左右子树,时间复杂度O(n),空间复杂度O(h)
2. 使用迭代法,维护两个栈,一个记录节点一个记录结果,每次pop出一个节点,将它的子节点压入栈(先右后左),循环迭代,时间复杂度和空间复杂度均为O(n)

## leetcode_429
1. 使用队列法,广度优先搜索,将节点用一个队列维护,用一个数组来记录结果,每次从队列左端推出一个节点,记录它的值后遍历他的子节点并塞入队列的后端,依次循环,时间复杂度和空间复杂度均为O(n)
2. 使用递归方法,用数组记录结果,level记录层数,递归过程传入层数参数,这样不论如何循环结果的数组都不会乱,时间复杂度和空间复杂度都是O(n)
## leetcode_236
1. 考虑四种情况:
    * 左子树返回root,右子树返回None,则说明左子树中有节点或答案,返回左子树返回的root
    * 右子树返回root,左子树返回None,则说明右子树中有节点或答案,返回右子树返回的root
    * 左右子树均返回root,说明答案就是现在状态的根节点本身,返回root
    * 左右子树均返回None,说明答案和节点在当前状态下均没有找到,只能返回None

此时秩序递归left和right,则可将答案传递回第一层,时间复杂度和空间复杂度都为O(n),因为可能为斜二叉树
2. 利用python中bool可以直接进行加减运算的特性,在函数递归中传递真值,若在改子树中找到p,q或答案都会将其置True,若根节点等于p或q也置为True,此时只需判断left,right,mid中是否有两个True时,用一个类变量储存此时的根节点即为答案,时间复杂度和空间复杂度均为O(n)

## leetcode_105
1. 寻找递归的循环模式：
    * 不断的从preorder中依次选取根节点，找到inorder中节点的位置
    * 此时inorder中该节点左边为其全部左子树，而右边为全部右子树
    * 对两个数组进行切片，分别将左子树和右子树当做一个完整的树去调用函数，形成递归
    * 每次调用函数返回根节点，生成节点并分别赋予左右子树节点值
    * 左右子树的节点的赋值即为它们作为完整子树传入函数的返回的节点
    * 终止条件为任意一个数组为空即停止递归
    * 其中mid既为左子树的个数，又为inorder中根节点的下标，所以在两个数组中均可以使用

## leetcode_77
1. 回溯法，在函数内部定义一个函数逐个遍历数字，每遍历一个数字则递归它的下一个数字子问题，所有数字被加入cur后只考虑添加后面的数字则不会产生重复项，当cur长度达到k时，说明一个子答案已经生成，则添加到结果数组当中

## leetcode_46
1. 回溯法，该题可比喻成此种场景：
    * 假设有一条生产线，生产线旁有一面镜子
    * 镜子中有同样的一条生产线，镜中的生产线也有一面镜子，依次递归
    * 生产工人在一个零件上组装另一个零件之后，复制给镜像中的生产线工人，让他在这个组合零件的基础上重复他的操作
    * 然后把这个刚装上的零件拆掉，安上另一个零件，再复制给镜中，再拆掉，直到零件库中的所有零件都被安装过
    * 如果某一面镜子中发生所有零件都组合到一起的情况，由记录员记录这一组合
    * 重复此过程

## leetcode_47
1. 回溯法，与之前不同的是有重复的元素，需要一个tmp规定选取元素的范围，在递归过程中不断的规避已选取的元素，等同于缩小元素库的范围，其他同上
 


