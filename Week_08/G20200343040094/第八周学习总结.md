## 位运算

### 核心要领

想要熟练掌握位运算，**记住下面几个公式**即可：

- 清除 n 最低位的 1：`n & (n - 1)`
- 获取 n 最低位的 1：`n & -n`
- 整除 2：`n >> 1`
- 判断奇偶：` n & 1 == 1 | 0`
- `n & ~n = 0`

### 经典例题

#### [52. NQueens II](https://leetcode-cn.com/problems/n-queens-ii/)

思路：

1. 位运算
   - 0 - 不能放皇后，1 - 能放
   - `availPos = (~(cols | pie | na)) & ((1 << n) - 1)`  考虑整行、两条对角线，得到当前能放皇后的位置，用最低的 n 位表示
   - `p = availPos & -availPos` 取得 availPos 最低位的1，用来放皇后
   - `availPos &= (availPos - 1)` 清除最低位的 1，表示皇后已放
   - `dfs(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1)` 对 cols, pie, na 可放皇后的位置做相应的更新，下探下一层(Drill Down)

```java
class Solution {
    private int count = 0;

    public int totalNQueens(int n) {
        dfs(n, 0, 0, 0, 0);
        return count;
    }

    private void dfs(int n, int row, int cols, int pie, int na) {
        if (row == n) {
            count++;
            return;
        }
        int availPos = (~(cols | pie | na)) & ((1 << n) - 1);
        while (availPos != 0) {
            int p = availPos & -availPos;
            availPos &= (availPos - 1);
            dfs(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1);
        }
    }
}
```

## 布隆过滤器

![](https://user-gold-cdn.xitu.io/2020/4/30/171ca51ee564a2e5?w=1846&h=946&f=png&s=420595)

布隆过滤器由一个很长的二进制向量和一系列随机映射函数组成。用于检索一个元素是否在一个集合中。

优点是**空间效率和查询时间远超一般算法**，缺点是**有一定的错误识别率和删除困难**。

### 重点

布隆过滤器是一个快速判断元素是否存在集合的算法，特点是：

1. 不需要像哈希表一样存额外的信息
2. 只能判断**肯定不存在**或**可能存在**
3. 适合用作**高速缓存**，如判断为可能存在，再到数据库中查询
4. 每个元素的存在用几个二进制位置1来表示
5. 多用于大型分布式系统如比特币网络、Redis缓存、垃圾邮件或评论过滤器等

## LRU Cache

一种CPU缓存策略，LRU：Latest Recently Used 最近最少使用。

![](https://user-gold-cdn.xitu.io/2020/4/30/171ca51498d01445?w=1918&h=950&f=png&s=129308)

### 硬核实现一个 LRU Cache

首先我们明确两个需求：

- 我们想要增删的时间复杂度为O(1)，LinkedList
- 还想随机访问的时间复杂度为O(1)，HashTable

```java
class Node {
    public int key, val;
    public Node next, prev;

    public Node(int k, int v) {
        this.key = k;
        this.val = v;
    }
}

class DoubleLinkedList {
    private Node head, tail; // 头尾虚节点
    private int size; // 链表元素数

    public DoubleLinkedList() {
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
        size = 0;
    }

    // 在链表头部添加节点
    public void addFirst(Node node) {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
        size++;
    }
    
    // 删除链表中的节点（该节点一定存在）
    public void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        size--;
    }
    
    // 删除链表中最后一个节点，并返回该节点
    public Node removeLast() {
        if (tail.prev == head)
            return null;
        Node last = tail.prev;
        remove(last);
        return last;
    }
    
    // 返回链表长度
    public int size() {
        return size;
    }
}

class LRUCache {
    private HashMap<Integer, Node> map;
    private DoubleLinkedList cache;
    private int cap; // 最大容量

    public LRUCache(int capacity) {
        this.cap = capacity;
        map = new HashMap<>();
        cache = new DoubleLinkedList();
    }

    // 访问节点
    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        int val = map.get(key).val;
        // 使用put方法把最近访问的节点提前
        put(key, val);
        return val;
    }

    public void put(int key, int value) {
        // 生成新的节点
        Node node = new Node(key, value);
        if (map.containsKey(key)) {
            // 删除旧的节点，新的插到头部
            cache.remove(map.get(key));
            cache.addFirst(node);
            // 更新 map 中对应的数据
            map.put(key, node);
        } else {
            if (cap == cache.size()) {
                // 删除链表最后一个数据
                Node last = cache.removeLast();
                map.remove(last.key);
            }
            // 直接添加到头部
            cache.addFirst(node);
            map.put(key, node);
        }
    }
}
```



也是[LeetCode 146](https://leetcode-cn.com/problems/lru-cache/)的题解




## 排序算法

### 算法复杂度

![](https://user-gold-cdn.xitu.io/2020/4/30/171ca4f61d48bab0?w=1304&h=880&f=png&s=302820)

### 三大O(nlogn)算法

#### 快速排序

```java
package SortAlgorithms;

import java.util.Arrays;

public class QuickSort {
    public void quickSort(int[] array, int begin, int end) {
        if (begin >= end) return;
        int pivot = partition(array, begin, end);
        quickSort(array, begin, pivot - 1);
        quickSort(array, pivot + 1, end);
    }

    private int partition(int[] a, int begin, int end) {
        int pivot = end, counter = begin;
        for (int i = begin; i < end; ++i) {
            if (a[i] < a[pivot]) {
                int temp = a[counter];
                a[counter] = a[i];
                a[i] = temp;
                counter++;
            }
        }
        int temp = a[pivot];
        a[pivot] = a[counter];
        a[counter] = temp;
        return counter;
    }

    public static void main(String[] args) {
        QuickSort qs = new QuickSort();
        int[] a = new int[]{5, 8, 9, 1, 5, 2, 90, -3};
        qs.quickSort(a, 0, a.length - 1);
        System.out.println(Arrays.toString(a));
    }
}
```



#### 归并排序

```java
package SortAlgorithms;

import java.util.Arrays;

public class MergeSort {
    public void mergeSort(int[] array, int begin, int end) {
        if (begin >= end) return;
        int mid = (begin + end) >> 1;
        mergeSort(array, begin, mid);
        mergeSort(array, mid + 1, end);
        merge(array, begin, mid, end);
    }

    private void merge(int[] array, int begin, int mid, int end) {
        int[] temp = new int[end - begin + 1];
        int i = begin, j = mid + 1, k = 0;
        while (i <= mid && j <= end) {
            temp[k++] = array[i] < array[j] ? array[i++] : array[j++];
        }
        while (i <= mid) temp[k++] = array[i++];
        while (j <= end) temp[k++] = array[j++];
        System.arraycopy(temp, 0, array, begin, temp.length);
    }

    public static void main(String[] args) {
        MergeSort mgs = new MergeSort();
        int[] a = new int[]{5, 8, 9, 1, 5, 2, 90, -3};
        mgs.mergeSort(a, 0, a.length - 1);
        System.out.println(Arrays.toString(a));
    }
}
```



#### 堆排序

```java
package SortAlgorithms;

import java.util.Arrays;

public class HeapSort {
    public void heapsort(int[] array) {
        int len = array.length;
        if (len == 0) return;
        for (int i = len / 2 - 1; i >= 0; --i) {
            heapify(array, len, i);
        }
        for (int i = len - 1; i >= 0; --i) {
            int temp = array[i];
            array[i] = array[0];
            array[0] = temp;
            heapify(array, i, 0);
        }
    }

    private void heapify(int[] array, int length, int i) {
        int left = 2 * i + 1, right = 2 * i + 2;
        int largest = i;
        if (left < length && array[left] > array[largest]) largest = left;
        if (right < length && array[right] > array[largest]) largest = right;
        if (largest != i) {
            int temp = array[i];
            array[i] = array[largest];
            array[largest] = temp;
            heapify(array, length, largest);
        }
    }

    public static void main(String[] args) {
        HeapSort hps = new HeapSort();
        int[] a = new int[]{5, 8, 9, 1, 5, 2, 90, -3};
        hps.heapsort(a);
        System.out.println(Arrays.toString(a));
    }
}
```