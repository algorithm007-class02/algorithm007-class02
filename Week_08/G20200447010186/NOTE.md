## 排序

下面按照时间复杂度来划分为三大类。

``` 
O(n2): 冒泡、插入、选择
O(nlogn)：快排、归并排序
O(n)：桶排序、计数排序、基数排序
```

### 如何分析一个【排序算法】

#### 一、 执行效率方面

1. 需要给出时间复杂度的三种常见情况。

* 最好情况
* 最坏情况
* 平均情况

2. 明确时间复杂度的系数、常数、底阶
3. 知晓比较次数 和 交换次数（基于比较的排序算法的执行过程，会涉及两种操作：一种是元素比较大小，另一种是元素交换或移动）

#### 二、 内存消耗方面

算法可以通过衡量空间复杂度来知道内存消耗，排序算法也如此。

针对排序算法的空间复杂度，还会引入【原地排序】概念，特指空间复杂度为 O(1)的排序算法。

#### 三、 稳定性方面

仅仅用【执行效率】和【内存消耗】来衡量排序算法的好坏是不够的，还有一个针对排序算法的重要度量指标：稳定性。

**稳定性**：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

拥有稳定性的排序算法叫【稳定的排序算法】。

不具有稳定性的排序算法叫【不稳定的排序算法】。

##### 为什么要考察稳定性？？

在真正的企业开发中，往往需要根据一个列表中的每个对象的 key 来排序。

场景：电商交易的订单排序，希望按照金额的从小到大排序，但肯定存在金额相同的单子，对于这些单子，我们希望依据下单时间的先后进行排序。

暴力做法：先统一按照金额的大小升序排列。然后遍历新数组，找到金额相同的区间，内部再根据下单时间进行升序排列。这种方法思路不难，但是实现比较复杂繁琐。

使用【稳定的排序算法】：先按照下单时间统一排列，然后再使用【稳定的排序算法】对新数组再依据金额大小统一排列。这样的好处是，由于稳定性，使得第二遍排列时，金额相同的数据的相对前后顺序不变。

### 初级：O(n2)排序算法

#### 冒泡排序：Bubble Sort

冒泡排序只会操作相邻的两个数。每次冒泡时比较其相邻数的大小关系，看是否满足约定的顺序，不满足则交换位置。每一次冒泡会让至少一个元素找到自己该在的位置，进行 n 次冒泡，就完成了长度为 n 的数据集合的排序。

1.  冒泡排序是原地排序吗？

    是。因为只涉及了交换数据，不会重新开辟新空间。

2.  冒泡排序是稳定的排序算法吗？

    是。冒泡排序只根据相邻元素的大小决定是否交换，当相邻元素大小相等时，不做交换。

3.  冒泡排序时间复杂度如何？

    需要分析最好、最坏、平均。

    最好：一开始就为有序数组，冒泡一次之后就可以结束了，为 O(1)；

    最坏：每次冒泡需要遍历整个数组，为 n 次。整个数组又需要 n 次冒泡。故 n \* n O(n2)。

    平均：平均时间复杂度就是加权平均期望时间复杂度，但比较复杂。还有一种思路，通过“有序度”和“逆序度”这两个概念来进行分析。（可在课堂巩固）

        有序度是数组中具有“有序”关系的元素对的个数。有序元素对：a[i] <= a[j](i < j)。（默认从小到大为有序）

        逆序度是数组中具有“逆序”关系的元素对的个数。逆序元素对：a[i] > a[j](i < j)。（默认从小到大为有序）

#### 插入排序：Insertion Sort

首先，将数组分为【已排序区间】、【未排序区间】。初始已排序区间只有数组头元素。

插入排序的思想是：取未排序区间中的元素，在已排序区间中找到合适的位置将其放入，保证已排序区间里一直有序。重复此过程，直至未排序区间空，结束。

插入排序包含两种操作：元素的比较、元素的移动。

当需要将一个元素从未排序区间放入已排序区间时，需要【依次比对】已排序区间内的元素，放入合适位置。并将放入点之后的元素【依次往后移动】一个位置。

1. 插入排序是原地排序吗？

   是。并不需要额外的存储空间，空间复杂度为 O(1)

2. 插入排序是稳定的排序算法吗？

   是。对于值相同的情况，可以将后面出现的元素插入到已出现元素的后方，就可以保持原有前后顺序不变。

3. 插入排序时间复杂度如何？

   最好：初始未排序区间为空，不需要搬移任何数据。只需 O(n)

   最坏：初始有序区间为空，每次为当前值寻找合适的插入位置，需要移动大量数据，为 O(n2)

   对于插入排序来说：

   - 需要遍历数组中每个元素，为其找到合适的位置，遍历为 O(n)。
   - 每次插入操作都相当于在数组中插入新元素，这个插入到数组的操作需要搬移数组中之后的元素，所以插入复杂度为 O(n)。
   - 综合上面，为 O(n2)

#### 选择排序 Selection Sort

选择排序的做法其实类似于插入排序，也分已排序区间和未排序区间。不同的是选择排序每次从未排序区间找到最小的元素，放在已排序区间的末尾。

思想：

* 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
* 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
* 重复第二步，直到所有元素均排序完毕

1. 选择排序是原地排序吗？

   是。不需要额外储存空间，空间复杂度为 O(1)

2. 选择排序是稳定的排序算法吗？

   否。不稳定，每次都要找剩余元素中的最小值，和前面的元素交换位置，破坏了稳定性。

3. 选择排序时间复杂度如何？

   最好、最坏、平均都为 O(n2)

### O(logn)的排序：

#### 归并排序

> 比较适合大规模数据的排序，用到了分治思想。

思想：若要对一个将数组排序，则从中间分为前后两区间，然后对前后两区间分别排序，再将排序后的组合在一起。主要使用的是分治思想，将大问题变为小问题

## 课堂笔记

排序分为 2 大类：比较类排序、非比较类排序。

重点掌握 O(nlogn)排序算法：堆排序、快速排序、归并排序。

### 比较类（工业编程用的最多）

通过比较来决定元素间相对顺序。由于此种办法时间复杂度无法突破 O(nlogn), 所以称为【非线性时间比较类排序】。

### 非比较类

不通过比较来决定元素之间的顺序。可以突破【比较类排序】的时间下限，以线性时间运行，所以称为【线性时间非比较类排序】。

### O(n2)初级复杂度排序有哪些？

1. 选择排序：每次找最小值，放到待排序数组的起始位置（最小值与起始元素互相对换位置）。
2. 插入排序：从前到后依次构建有序区间；对于未排序数据，在已排序区间中从尾到头依次扫描，找出合适位置并插入,一直保持前面的有序区间一直有序。

   - 最大问题：每次插入时，需要后面数组内所有元素的挪动。

3. 冒泡排序：2 层嵌套循环，每次比较前后 2 元素，如果逆序则交换位置。

   - 在最内层循环，比较相邻元素的顺序，如果逆序则交换。

### O(nlongn)高级排序有哪些？ ！！需要重点掌握

1. 快速排序：在待排序的数列中，我们首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择中间值作为基准数（其实选择第几个并没有关系）。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边，这时，左右两个分区的元素就相对有序了。接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。

   - 思想：分治（将原问题划分为若干与原问题类似子问题，解决这些子问题，将子问题的解组成原问题的解），要降复杂度，必须要分治。
   - 标杆选择：一般在中间，也可头/尾。
   - 但是由于快速排序需要对数列中的元素来回移动，有时还是会改变相对顺序的。所以快速排序并不是一个稳定的算法

2. 归并排序：

   - 第一步：直接从中间位置把数组分成 2 个子序列。
   - 第二步：对两个子序列分别采用归并排序。
   - 第三步：将这 2 个排好序的子序列合并成最终序列。

3. 堆排序：

   操作：堆插入：O(logn)；取最大、最小值：O(1)

   - 第一步：根据数组元素建立小顶堆
   - 第二步：依次取堆顶元素，并删除

##### 总结：归并和快排其实具有相似性，仅顺序相反。

* 归并：先排序左右子数组，再合并两有序子数组
* 快排：先根据规则（左边区间的值都小于右边区间的值）调配出左右数组，再对左右数组进行排序

#### 特殊排序（对原数组有一定要求）

1. 计数排序 Counting Sort（不是基于比较的排序，线性时间复杂度）

   要求：输入的数必须为确定范围的整数。
   适用于：要比较的量很大，但是范围比较小的情况。如高考名次，xx万人比较，但范围0-750
   操作：1. 找出数组的最大值max，设立一个计数数组，长度为max+1，来保证计数数组的下标为0--max的范围。

        2. 遍历数组中每个值元素出现的次数，将该值出现的次数存在下标为该值处。

        （不好点：如果数组中max过大，比如100000，直接导致计数数组长度100001）

        3. 计数数组整理完毕后，此时需要再开辟一个结果数组。

        4. 从头开始遍历计数数组，根据计数数组下标对应的值x，在结果数组中写入x次该下标。

   空间复杂度：n+k （n：结果数组，【长度】为待排序数组的项数。k：计数数组，【长度】为数组中最大值+1）
   时间复杂度：遍历原数组n次，写入结果数组n次，遍历计数数组k次。故O(n+k) 约等于 O(n)

2. 桶排序 Bucket Sort

   简介：计数排序的升级版，利用了函数的映射。高效与否的关键就在于这个映射函数的确定
   思想：假设原始数组服从均匀分布，将数组元素分到有限数量的桶里，每个桶再分别排序（对于每个桶有可能再使用别的排序算法或是以递归方式继续使用桶排序）

   操作： 

         1. 设置一个定量的数组当作空桶；
         2. 遍历原始数组，并且把元素一个一个放到对应的桶里去；
         3. 对每个不是空的桶进行排序；
         4.从不是空的桶里把排好序的数据拼接起来

3. 基数排序

   思想：对原始数组按照低位先排序，然后收集；再按照比上一次高的高位排序，然后再收集；依次类推，直到最高位。
   限制：只能用于整数
   操作：

      1. 取得数组中的最大数，并取得其具有的位数；如1000，位数是4；
      2. 在原始数组中，取每一个数组元素的最低位，构成一个中间数组；
      3. 对中间数组进行计数排序，完成之后对这些元素再进行高一位的比较，依次类推，直到最高位。
