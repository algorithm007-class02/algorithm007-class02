**课堂笔记**

1. 数组的插入
  	平均要移动一半的元素位置。
  数组的删除

  

2. 链表的增加和删除

  ​	单项链表、双向链表、循环链表	

  ​	java里的linked List是双向链表结构

  ​	Linked List的增加、移动、删除造作都是O(1)，但要访问某个节点时的时间复杂度为O(n)
  

  数组有序时可以通过二分查找减小查询操作的时间复杂度，很快的查询位置或者是查询元素是否存在于数组。但是当面对的是有序链表时，为了提高查询速率，1989年出现了名为“跳表”的数据结构（比平衡树，二叉树，二叉搜索树等晚出现了30年，常在一些热门项目里用来替换平衡树，如，在服务器端用来做缓存的Redis，LevelDB）。

  

3. 跳表（skip list）
  对标的是平衡树（AVL Tree）和二分查找，是一种 插入、删除、搜索 都是O(logn)的数据结构。###注，跳表只能用于元素有序的情况。或者说，跳表里的元素始终是有序的。
  跳表查询的时间复杂度详见word（跳表的时间复杂度分析---跳表如何加速）。

  结论是，索引的高度是logn，经过的节点数为3，总体的时间复杂度为O(logn)
  （如，当查找的元素为有序链表的第八个元素时，索引高度为log8=3---即使用了三级索引，在三级索引共经过3的节点后找到目标节点）
  （这就使得，比如目标元素为第1024个、在原来使用数组时要查询1024次，使用跳表后只需要查询log1024=10次）

  但是，快速是有代价的。
  跳表的维护成本比较高---当增加和删除元素的时候索引都要更新，增加和删除操作的时间复杂度就变为n了。而且当元素增加或者删除时，可能会导致索引的“跨度”发生改变（有些地方会跨几步，有些地方会少跨几步）。

  跳表的空间复杂度为O(n）
  空间复杂度分析：当每两个加点抽一个作为索引，每层的结点数为（n/2、n/4、n/8...n/(2^k)...8、4、2）,因违反是收敛的，它们的和的数量级为O(n)。原始链表的时间复杂度也是O(n)。

4. 贯穿整个算法训练营，“加速”的核心思想：
  一维的数据结构要“加速”的话，经常采用“升维”的方式。
  也就是说一维变成二维。多一维就会多一级的信息，增加的这些信息就能帮你快速地得到原来一维里那些你必须挨个走才能走到的那些元素。

5. 面试时，
  对于数组和链表的操作的时间复杂度一定要非常的清晰；
  还要明确在某种情形下使用某种数据结构是否得当；
  还要了解Redis或者LRU Cache中用的是什么。