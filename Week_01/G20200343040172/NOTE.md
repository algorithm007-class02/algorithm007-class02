学习笔记
这个星期重点学习了==Array==和==LinkedList==。Array和LinkedList的理论并不是很难，各自的特点也比较鲜明。
* Array的内存是连续的，通过下面这个公式就能以O(1)的时间复杂度访问Array中的任意一个元素。
$$a[i]address = baseAddress + i * dataTypeSize$$
与此同时，其缺点也比较鲜明，如果是申请一些小的内存空间没什么问题，但是如果要申请1G，2G甚至更大的内存就有问题了。当内存中没有这么大的连续内存空间的时候，就会出现申请失败的情况。而且，删除或者是向Array中插入元素，为了维护内存空间的连续性，需要搬移大量的元素，时间复杂度是比较高的，平均下来都是O(N)的时间复杂度。
* LinkedList与Array相反，内存不连续，插入和删除都是O(1)的时间复杂度，但是查找则是O(N)的时间复杂度。

掌握了这些理论，只能说是在宏观上对Array和LinkedList有了一定的认识，距离真正掌握Array和LinkedList仍有不小的距离。特别是在做题的时候就会发现，即便对于这些理论已经很熟悉了，依然写不出优美的LinkedList的代码。需要大量且重复的练习，需要将其从掌握理论的阶段上升到看到题就能产生条件反应的阶段，才能真正掌握Array和LinkedList。
我将这星期学习过程中的心得和思考总结如下：
* 在做LinkedList的题目的时候，一定少不了纸和笔，少不了勾勾画画。只有通过这种画图的方式，对于哪个指针指向哪个节点，进行删除或者插入的时候先动哪个指针，再动哪个指针，才能了然于胸。人脑很难处理太过复杂的问题，所以我们需要将一个个的问题划分开，逐个击破，通过在纸上画图，打草稿，能将代码以及执行过程走一个流程。在这个过程中，不仅会加深自己的印象，更会对执行过程中的脉络有一个更深的理解。
* 在做LinkedList的时候，大部分问题都可以通过递归的方法去解决。我对递归的理解如下：以两两交换链表中的节点为例，在一次代码的执行中，我们只需要负责本次代码所需要交换的两个节点，而对于其他节点，我只负责传入下一次递归。以交换下面一个链表中相邻的元素为例，对于我个人来说，我的思维是从左到右。
$$1→2→3→4→Null$$因此，拿到这样的题目，我第一感觉是先交换1和2节点，1和2交换完毕以后再继续往下走。对于递归代码则不是从左到右，而是从右到左的顺序进行执行。
我模拟一下机器的思维：要交换1和2节点很简单，但是我交换完1和2节点以后再去指向3则不对，因为3和4也要交换，我应该要去指向4才对。但是我只能管我当前两个节点的交换，我管不了3和4呀。怎么办？等着呗，我等3和4交换完毕以后我再进行交换，然后就可以顺利成章的指向交换过后的4了。上面的例子比较简单。当3和4准备交换的时候，发现自己是最后两个节点，本来是指向Null，交换完毕还是指向Null。那就没有1和2节点的后顾之忧了，可以大胆交换了。若3和4节点并非最后的节点，它们也会重复1和2的动作，等下面两个节点交换完毕，再进行交换。所以对于机器来说则是从右到左开始执行的。我觉得明白了这些，在理解递归代码的时候还是比较容易的，但是距离写出优雅的递归代码，还有很多路要走。
* 使用Map和Set的时候，通常思路都是先将元素放入Map和Set中，然后在进行遍历的时候来进行查找看Map和Set中是否包含该元素。我的想法则是这样的，对于Map来说，直接将元素put进行，若put成功，则说明之前Map中没有该元素(针对Map中的Key，因为Key不能重复，但是Value可以重复)，同时会返回一个null，若put不成功，则会返回非null，同时也说明该Map中已经存在了当前想要put进去的元素。这样就可以做到在put的时候就可以进行查找，无需调用额外的containsKey方法进行查询。使用Set的时候也同理，若add成功则会返回true，否则返回false，利用返回值的不同来进行插入+查询。
