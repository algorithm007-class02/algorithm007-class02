# 学习笔记
## leetcode_26

1. 配置一个初始化无穷大的tmp变量用于存储参数,在删除过程中用于比对并实时更新,空间复杂度O(1)
2. 双指针法,利用快慢指针,慢指针标记最后一个非重复元素,快指针遍历,并送回最新的不重复元素,替代掉慢指针的下一位,空间复杂度O(1)
##### tips:注意审题!要返回新的数组长度,并且可以忽略超出新长度的部分.

## leetcode_189

1. 三次翻转,利用python切片简单易写,以-k为分割进行分别翻转赋值,但是好像不满足空间复杂度O(1)
2. 循环填充,利用缓存变量救下下一个要被填充的变量,循环len(nums)次,但是需要注意len(nums)%k==0的情况,此时会多次回到重复点,需要进行移位处理,空间复杂度O(1)
3. 栈入栈出,移花接木,代码简单但是由于数组插入导致时间复杂度较高O(kn).

## leetcode_21

1. 比较好想的迭代法，注意控制边界l1或l2为空的情况，提前设置哨兵节点以便返回，时间复杂度O(n+m),空间复杂度O(1)。
2. 迭代法绕一点但是很巧妙，类似事件树的递归结构，可以先写条件迭代公式会好想一点，关键是寻找合适的循环模块，同样要注意l1或l2为空的情况,时间复杂度和空间复杂度均为O(n+m)

## leetcode_88

1. 迭代法，由于需要原地修改nums1，所以从小到大填进数组需要额外的空间存储nums1中原来的元素；从大到小填入则替代0元素，不会影响原数组，故逆向迭代，时间复杂度O(n+m)，空间复杂度O(1)

## leetcode_1

1. 暴力迭代法，很好想就是把所有可能穷举一遍，但是时间复杂度O(n*n)太慢，空间复杂度O(1)
2. 字典，即哈希表，记录下数字及其对应的角标，每次对比target-nums[i]在不在字典内，时间复杂度O(n),空间复杂度O(n)，典型的空间换时间解法