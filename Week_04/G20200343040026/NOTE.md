# 学习笔记

## leetcode_860
1. 贪心解法，用一个字典记录手中5元和10元的数量，穷举所有case:
* 从左到右遍历bills
* 若5元，则收下，5元记录加1
* 若10元，优先找零，5元记录减1，再将10元记录加1
* 若二十元，优先查找是否有10元，有则再找1张5元，5元10元记录都减1
* 若二十元且手中无1-元，则找3张5元，5元记录减1
* 判断5元记录是否为负，若是则返回False，否则继续遍历bill
* 最终顺利遍历完成，返回True
   
## leetcode_122
1. 贪心解法:
* 检测边界，如果没有开盘或只有一天，收益必为0
* 只要今天比前一天的价格高，前一天就买入然后今天卖出
* 若明天的价格比今天高，则今天的买入，明天卖出
* 依次循环，直到最后一天

## leetcode_455
1. 贪心解法:
* 探测边界，没有饼干或没有孩子都返回0
* 对孩子和饼干排序
* 拿出最大的饼干，从胃口大到小找能吃饱的孩子
* 若不够吃，直接将孩子pop出，不管
* 若够吃，也pop出孩子，记录数值+1，跳出该循环，继续大循环
* 重复此过程直至没有饼干或没有孩子
* 如果当前最大的饼干满足不了最小胃口的孩子，直接跳出大循环

## leetcode_874
1. 设定方向向量，模拟机器人一步一步行走的过程
* 方向向量的方向为上右下左，对应正向遍历为右转90°，反向为左转90°
* 重要！将障碍物坐标列表转化为元组集合，因为set的结构是哈希表，查找元素要比列表快很多
* 判断命令正负，负则转方向，正则走步
* 走步时判断是否踩到障碍物，是则退回来一步
* 走完每一步计算一下和原点的距离，如果为历史最大则记录

## leetcode_127
1. BFS广度优先遍历
* 检测边界
* 对词库进行预处理，只在某位置字母不同的词归到一类，用dict存储，key为a*b
* 建立队列存储BFS过程中的词，访问过的词存入集合visited
* 一层一层广度优先遍历，返回时要把层数和单词一同压入队列
* 找到与结果相同的词时返回层数+1（因为找到的词是当前层的词的相似词，所以在下一层要+1）

## leetcode_200
1. DFS深度优先遍历
* 检测边界，若为空则返回0
* 定义方向向量，注意坐标系方向
* 依次遍历所有节点，每个节点进入findland函数，如果返回True则找到一个岛，结果+1
* findland中对进入的节点进行判断，如果是陆地则先将它置0
* 继续寻找它上下四方的区域是否为陆地，递归操作
* 最后返回True
* 如果不是则直接返回False

## leetcode_529
1. DFS深度优先遍历
* 首先判断点击是否踩雷，是则直接改X返回
* 若不是则定义dfs递归函数和寻找一个点周围有多少颗雷的函数
* 开始dfs，将这个点记录visited
* 判断该点状态，只有当当前为E,即未点击的状态才进行下一步，否则直接返回
* 首先判断改点周围有多少雷，若周围有雷则不进行递归，改为数量后返回
* 若周围无雷，则按顺序向八个方向递归
* 若某方向前进一步出边界或该点已遍历过（在visited内），则该点不进行递归

## leetcode_55
1. 贪心解法
* 从后向前遍历数组，从最后一个元素A开始
* 找到最近的一个可以到达当前元素A位置的元素B
* 再以B为起始位置，找到离B最近的一个可以到达B元素的位置C
* 依次循环，如果最后遍历到0位置都顺利找到元素，则返回True
* 若某一个元素在寻找时直到0位置也没有找到，就返回False
* 证明：
    * 在第一步时,若没有找到B，则所有元素都访问不到A；
    * 若找到B，则可认为B为A的中继站，到达A可以通过直接到达A或到达B再转来实现目的；
    * 此时若找不到C,由于数组为一维单向空间，如果连B都到达不了，更不用说到A了，所以此时可以保证没有解；
    * 若找到C，那么相当于两个中继站之间连接通信，下一步只要找到可以到达A或B或C的元素就可以了；
    * 而C点对于前面的元素来说最好到达，如果连C都到不了那么肯定无解；
    * 依次类推，如果最后推到0位置，说明通信完全联通，否则中间有一个中继站找不到节点，就会到不了0位置

## leetcode_33
1. 二分查找一趟递归法
* 设定终止条件：
    1. 传入数组为空时,说明最后没有找到target,返回-1
    2. 传入数组只含一个元素时，无法再进行二分，因此只需判断该元素是否为target即可
* 设定判定，先将数组二分，判断中间的元素是否为target，如果是则返回下标，否则继续进行分类递归
* 设定在左边数组进行递归的条件，递归后不管有没有找到直接返回递归结果即可：
    1. 左边数组为升序，如果nums[0]<=target<=nums[mid-1]即可
    2. 左边数组为乱序，转折点在其中，那么需要target>=nums[0]>nums[mid-1]或target<=nums[mid-1]<nums[0]

* 设定在右边数组进行递归的条件：
    1.其他情况均可在右边数组中递归，递归后若找到需要将结果（相对下标）+mid再返回，没找到则直接返回-1

## leetcode_153
1. 二分查找迭代法
* 本质就是找到转折点
* 判定边界：
    1. 如果数组为空，返回None
    2. 如果数组中只有一个元素无法二分，那么该元素就是最小值
    3. 如果尾元素大于首元素，说明转折点就是第一个元素，不然数组不可能是顺序的
* 设定左右指针
* 当做指针小于右指针时，迭代二分
* 如果左边为顺序，则在右边找
* 如果左边只有一个元素，也在右边找，因为如果转折点在左边那么只能是第一个点，和边界条件相悖
* 否则在右边找
* 循环结束时left=right，此时指向的就是转折点
* 返回nums[left]即可

## leetcode_74
1. 两遍二分查找法
* 判断边界，空数组就判False
* 将子list的每个首元素组成一个list
* 第一遍二分查找，找到可能在的子list的首元素的下标
* 这个下标即为该子list在matrix中的下标
* 再用二分查找寻找子list中是否有target
* 过程中如果遇到mid是target的情况就立刻返回True