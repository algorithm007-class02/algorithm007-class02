## Week03 学习笔记

## 搜索

每个节点都要访问一次

每个节点仅访问一次

对于每个节点的访问顺序不同，可分为 2 大类：

【深度优先搜索】：Depth First Search

【广度优先搜索】: Breadth First Search

按照节点的优先级搜索，称为【启发式搜索】。（推荐算法）

#### 深度优先搜索

```
/*
 * 递归方式
*/
// 以二叉树为例

function dfs(node, visited){
	if(visited.includes(node)){
    	return;
    }
    // current：将当前节点放入已拜访的节点数组
    visited.push(node);

    // next level
    // 对当前节点左子树执行dfs搜索
    dfs(node.left, visited);
    // 对当前节点右子树执行dfs搜索
    dfs(node.right, visited);
}

// 以多叉树为例

function dfs(node, visited){
	if(visited.includes(node)){
    	return;
    }
    // current：将当前节点放入已拜访的节点数组
    visited.push(node);

    // next level
    对当前节点的孩子进行遍历，对每个孩子节点执行dfs
    for(let item in node.children){
    	dfs(item, visited)
    }
}

```

#### 广度优先搜索

不再适合递归，用队列实现，利用队列的先进先出特性。

## 贪心算法

定义：一种在每一步选择时都采取在当前状态下【最好】【最优】的选择，从而希望导致全局最优的算法。

#### 区别：【贪心算法】与【动态规划】的不同

    【贪心算法】对每个子问题的解决办法都做出当前最优选择，不能反悔。

    【动态规划】会保存以前的运算结果，并根据以前的结果对当前进行选择，具有回退功能。

### 适用于贪心法解决的问题

求图中最小生成树、求哈夫曼编码等。

##### 然而现实工程中，贪心法一般不能得到我们期待的结果。

##### 一旦一个问题可以通过贪心法解决，那么贪心法一般是此问题的最优解法。

#### 由于贪心法的高效性以及贪心法所求的解一般比较接近于最优解，贪心法也可以作为辅助解法、或直接用于一些对计算结果要求不十分精确的问题。

### 何种情况下用到贪心算法

问题能够分成子问题求解，子问题的最优解能够递推到最终结果的最优解。子问题的最优解又称为最优子结构

## 二分查找

> 关键的 3 个前提条件 （必记住） 1.【目标函数的单调性（单调递增或者递减）】因为二分查找必须在有序的数据集合里使用，无序的必须从头到尾遍历 2.【能够通过索引访问数据】 3.【存在上下界】数据不能是无穷的，否则没法往中间找
